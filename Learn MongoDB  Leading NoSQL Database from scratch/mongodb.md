Script
======
- db.getUsers();
- db.createUser({user: <username>, pwd: <password>, roles: [{ role: 'userAdmin', db: <database_name> }]});
- mongod --auth --dbpath <db_directory_path> // open mongodb with authentication 
- db.auth(<user>, <password>);
- show dbs;
- use <database>;
- db.dropDatabase();
- show collections;
- db.createCollection(<string - collection_name>);
- db.<collection>.drop();
- db.<collection>.insert(<document>);
- db.<collection>.find();
- db.<collection>.find()[0];
- db.<collection>.find({ _id: ObjectId('idxxx') });
- db.<collection>.find().explain();
- db.<collection>.find().pretty();
- db.<collection>.save(<document>);
- load(<path_to_js_file_with_script>); // load file as script
- db.<collection>.createIndex({ age: 1 }) // 1 = ASC, -1 = DESC
- db.<collection>.getIndexes(); // return all indexes createdv
- db.<collection>.dropIndex({ age: 1 }); 
- db.<collection>.insert({ _id: 1, "name" : "king" }); // own object id - discourage
pros: easy for use (eg product/1); 
cons: object id can get timestamps (db.<collection>.find()[0]._id.getTimestamp())
- db.<collection>.aggregate(); 
- db.<collection>.distinct();
- db.<collection>.count();
- db.<collection>.sort();



Example
=======
- db.<collection>.find({"name.firstname": "Sunil"});
- db.<collection>.find({"age": {$eq: 21}});
- db.<collection>.find({"age": {$lt: 21}});
- db.<collection>.find({"age": {$gt: 21}});
- db.<collection>.find({"age": {$gte: 21}});
- db.<collection>.find({"age": {$lte: 21}});
- db.<collection>.find({"age": {$ne: 21}});
- db.<collection>.find({"age": {$in: [21, 31]}});
- db.<collection>.find({"age": {$exists: true, $nin: [21, 31]}});

- db.<collection>.uodate({"name.firstName": "Sunil", { $set: { "age": 20 } }})
- db.<collection>.uodate({"name.firstName": "Sunil", { $set: { "age": 20 } }, { upsert:true } }) // auto insert if the record not found

- db.<collection>.remove({"name.firstName": "Alun"});
- db.<collection>.remove({"name.firstName": "Alun"}, 1); // 1 mean delete only first record that matching the criteria
- db.<collection>.remove(); // remove all

- db.<collection>.aggregate([{$group: { _id: "$author", total_posts: {$sum:1} }}])
- db.<collection>.distinct("subjects");
- db.<collection>.count();
- db.<collection>.find({"subjects": "Maths"}).count();
- db.<collection>.sort({ age: 1 }); // 1 for ascending order, -1 for descending order
- db.<collection>.find().sort({ $natural: 1 });

- db.<collection>.find({empName:{$regex:"sunil"}});
- db.<collection>.find({empName:/Sunil/});

Doubt
=====
1. The way how mongodb sort data in natural, first based on insertion, second based on update, latest update put into last

Real Example
============
Assume below data, to get their total for both a and b for each name
{ Name: 'X', Prod: { 'a': 25, b: '75' } }
{ Name: 'Y', Prod: { 'a': 33, b: '66' } }
To solve this, we need both group by and reduce function
Answer:
db.<collection>.group({key:{'Name':1},reduce:function(curr,result){result.total+=curr.Prod.a+curr.Prod.b;},initial:{total:0}});

Others
======
1. Map-Reduce
- db.<collection>.mapReduce(
    function() { emit(this.emp_id, this.loanAmount) },
    function(key, values) { return Array.sum(values); },
    {
        query: { loanStatus: "Active" },
        out: "TotaLoan"
    }.find();
);
2. .toArray()
3. Namespace in mongodb = Database + Collection e.g. Udemy.course
4. ObjectId in Mongodb is a 12-byte JSON which generated by: timestamp, process id, counter, machine identifier
5. Mongodb does not use big amount of memory in order to run, where it can dynamicly change based on needs
6. It is recommended to run on 64bit machine rather than 32bit is because 32bit maximum support 2gb storage only, 64bit no limit
7. Why are mongoDB data files so large in size?
Because it pre-allocates the data files to avoid the file system fragmentation
8. When should we embed documents?
- For relationships between entities
- To achieve one-to-many relationship
- To improve the performance
10. Maximum 50 replica set (7 voting member, 34 non voting)
members[n].priority = 1;

Key Feature
===========
1. NoSQL
2. Faster than RDBMS
3. Agile
4. Highly Scalable
5. Flexible data model
6. Dynamic schema

Replica Set
===========
- mongod --replSet <replicat_set_name> --dbpath <database_directory_path>
> rs.status(); - show replicate set status
> rs.initiate(); - initiate the replica set

1 PRIMARY NODE and 2 REPLICA NODE
=================================
- Set port for each mongodb, use --port <port> when start the instance
- mongod --replSet <replicat_set_name> --dbpath <database_directory_path <<< different path for each>
- db.hostInfo(); < to get the hostName

In primary node
---------------
- rs.initiate();
- rs.add(<host_name>) - add other node to the replica set